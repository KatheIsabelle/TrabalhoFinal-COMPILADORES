PARSER_BEGIN(Bela)
import ast.*;
import java.util.*;
import java.io.*;
import java.nio.file.Files; // 
import java.nio.file.Paths; // 

public class Bela {
  public static void main(String args[]) throws Exception {
    FileInputStream fs = new FileInputStream(args[0]);
    Bela parser = new Bela(fs);
    Prog prog = parser.Bela(); // inicia a análise, aponta para raiz da árvore
    geraCodigo(prog, args[0]);
  }

 public static void geraCodigo(Prog prog, String arquivo) throws IOException {
    // Extrai o nome do arquivo sem a extensão (ex: "exemplo")
    String nomeClasse = arquivo.substring(0, arquivo.lastIndexOf('.'));
    
    // Usa o nome extraído para criar o nome do arquivo .java
    String nomeArquivoJava = nomeClasse + ".java";
    FileWriter fw = new FileWriter(nomeArquivoJava);
    PrintWriter out = new PrintWriter(fw);
    
    // Passa o nome da classe para o método de geração de código da árvore
    prog.gerarCodigo(out, nomeClasse); // Aqui começa a cascata!
    
    // Fecha o arquivo, garantindo que tudo foi salvo
    out.close();

    // --- INÍCIO: Novo código para imprimir o arquivo no terminal ---

    System.out.println("\n--- Código Gerado em '" + nomeArquivoJava + "' ---");
    
    // Lê todo o conteúdo do arquivo recém-criado para uma String
    String conteudo = Files.readString(Paths.get(nomeArquivoJava));
    
    // Imprime o conteúdo no terminal
    System.out.println(conteudo);
    
    // --- FIM: Novo código ---
  }
  
}
PARSER_END(Bela)


SKIP : { " " | "\t" | "\n" | "\r" }


TOKEN : {
  // Palavras reservadas da linguagem
  < MAIN: "main" >
| < VAR: "var" >
| < FLOAT_TYPE: "float" >
| < BOOL: "bool" >
| < VOID: "void" >
| < PRINTLN: "printLn" >
| < IF: "if" >
| < THEN: "then" >
| < WHILE: "while" >
| < RETURN: "return" >
| < READINPUT: "readInput" >
| < FUN: "fun" >

  // Símbolos da linguagem
| < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < SEMI: ";" >
| < COMMA: "," >
| < ASSIGN: "=" >

  // Operadores
| < PLUS: "+" >
| < MINUS: "-" >
| < MULT: "*" >
| < DIV: "/" >
| < AND: "&&" >
| < OR: "||" >
| < LT: "<" >
| < GT: ">" >
| < EQ: "==" >

  // Valores booleanos literais
| < TRUE: "true" >
| < FALSE: "false" >
}

TOKEN : {
  // Identificadores
  < ID: (["a"-"z","A"-"Z"]) (["a"-"z","A"-"Z","0"-"9"])* ( "_" (["a"-"z","A"-"Z","0"-"9"])+ )? >

  // Literais numéricos
| < NUM: (["0"-"9"])+ ("."(["0"-"9"])+)? (("e"|"E") (("+"|"-")? (["0"-"9"])+))? >
}


Prog Bela():
{
  ArrayList<Fun> funs = new ArrayList<Fun>();
  Main main;
  Fun f;
}
{
  main = blocoMain()
  (f=funcao() { funs.add(f); })*
  {
    return new Prog(main, funs);
  }
}

Fun funcao():
{
  String tipo;
  ArrayList<ParamFormalFun> params;
  ArrayList<VarDecl> vars;
  ArrayList<Comando> cmds;
  Token id;
}
{
  <FUN> tipo = tipo() id=<ID> <LPAREN> params = parametros() <RPAREN>
  <LBRACE>
    vars = varDecls()
    cmds = comandos()
  <RBRACE>
  {
    return new Fun(id.image, params, tipo, vars, cmds);
  }
}

Main blocoMain():
{
  ArrayList<VarDecl> vars;
  ArrayList<Comando> cmds;
}
{
  <MAIN> <LPAREN> <RPAREN> <LBRACE>
    vars = varDecls()
    cmds = comandos()
  <RBRACE>
  {
    return new Main(vars, cmds);
  }
}

ArrayList<VarDecl> varDecls():
{
  ArrayList<VarDecl> lista = new ArrayList<VarDecl>();
  VarDecl v;
}
{
  (v=varDecl() { lista.add(v); })*
  { return lista; }
}

VarDecl varDecl():
{
  String tipo;
  Token id;
}
{
  <VAR> tipo=tipo() id=<ID> <SEMI> { return new VarDecl(tipo, id.image); }
}

String tipo():
{
  Token t;
}
{
  t=<FLOAT_TYPE> { return "float"; }
| t=<BOOL> { return "bool"; }
| t=<VOID> { return "void"; }
}

ArrayList<ParamFormalFun> parametros():
{
  ArrayList<ParamFormalFun> lista = new ArrayList<ParamFormalFun>();
  ParamFormalFun p;
}
{
  (p=param() { lista.add(p); } (<COMMA> p=param() { lista.add(p); })*)?
  { return lista; }
}

ParamFormalFun param():
{
  String tipo;
  Token id;
}
{
  tipo=tipo() id=<ID> { return new ParamFormalFun(id.image, tipo); }
}

ArrayList<Comando> comandos():
{
  ArrayList<Comando> lista = new ArrayList<Comando>();
  Comando c;
}
{
  (c=comando() { lista.add(c); })*
  { return lista; }
}

Comando comando():
{
  Token id;
  Exp e;
  ArrayList<Comando> bloco;
  ArrayList<Exp> args;
}
{
  <PRINTLN> e=expressao() <SEMI> {
    return new CPrint(e);
  }
|
  <RETURN> e=expressao() <SEMI> {
    return new CReturn(e);
  }
|
  <IF> e=expressao() <THEN> <LBRACE> bloco=comandos() <RBRACE> {
    return new CIf(e, bloco);
  }
|
  <WHILE> e=expressao() <LBRACE> bloco=comandos() <RBRACE> {
    return new CWhile(e, bloco);
  }
|
  // ** A CORREÇÃO PRINCIPAL ESTÁ AQUI **
  // Usamos LOOKAHEAD para diferenciar uma chamada de função de uma atribuição.
  LOOKAHEAD( <ID> <LPAREN> )
  id=<ID> <LPAREN> { args = new ArrayList<>(); }
     (e=expressao() { args.add(e); } (<COMMA> e=expressao() { args.add(e); })*)?
  <RPAREN> <SEMI> {
    return new CChamadaFun(id.image, args);
  }
|
  // Regra para "id = readInput()"
  LOOKAHEAD( <ID> <ASSIGN> <READINPUT> )
  id=<ID> <ASSIGN> <READINPUT> <LPAREN> <RPAREN> <SEMI> {
    return new CReadInput(id.image);
  }
|
  // Regra para atribuição normal "id = expressao"
  id=<ID> <ASSIGN> e=expressao() <SEMI> {
    return new CAtribuicao(id.beginLine, id.image, e);
  }
}


Exp expressao():
{
  Exp e1, e2;
  Token op;
}
{
  e1=expressaoLogica() (
    op=<PLUS> e2=expressaoLogica() { e1 = new EOpExp(op.image, e1, e2); }
  | op=<MINUS> e2=expressaoLogica() { e1 = new EOpExp(op.image, e1, e2); }
  )*
  { return e1; }
}

Exp expressaoLogica():
{
  Exp e1, e2;
  Token op;
}
{
  e1=expressaoRelacional() (
    op=<AND> e2=expressaoRelacional() { e1 = new EOpExp(op.image, e1, e2); }
  | op=<OR> e2=expressaoRelacional() { e1 = new EOpExp(op.image, e1, e2); }
  )*
  { return e1; }
}

Exp expressaoRelacional():
{
  Exp e1, e2;
  Token op;
}
{
  e1=termo() (
    op=<LT> e2=termo() { e1 = new EOpExp(op.image, e1, e2); }
  | op=<GT> e2=termo() { e1 = new EOpExp(op.image, e1, e2); }
  | op=<EQ> e2=termo() { e1 = new EOpExp(op.image, e1, e2); }
  )*
  { return e1; }
}

Exp termo():
{
  Exp e1, e2;
  Token op;
}
{
  e1=fator() (
    op=<MULT> e2=fator() { e1 = new EOpExp(op.image, e1, e2); }
  | op=<DIV> e2=fator() { e1 = new EOpExp(op.image, e1, e2); }
  )*
  { return e1; }
}

Exp fator():
{
  Token t;
  ArrayList<Exp> args = new ArrayList<>();
  Exp e;
}
{
  t=<NUM> { return new EFloat(Float.parseFloat(t.image)); }
|
  t=<TRUE>  { return new ETrue(); }
|
  t=<FALSE> { return new EFalse(); }
|
  LOOKAHEAD( <ID> <LPAREN> )
  t=<ID> <LPAREN> { args = new ArrayList<>(); }
     (e=expressao() { args.add(e); } (<COMMA> e=expressao() { args.add(e); })*)?
  <RPAREN> {
    return new EChamadaFun(t.image, args);
  }
|
  t=<ID> { return new EVar(t.image); }
|
  <LPAREN> e=expressao() <RPAREN> { return e; }
}